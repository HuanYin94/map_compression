# To learn what is useful in a 3D map

mapCheck: 		just show the map

mapCompresser:		compress the map according to the saliency descriptor

sessionFilter:	make great session be salient! & brother_cnt to filter some lonely ones //score result GET

randomSampleMap:			random sampling the map for comparison

loadFinalResults:		load the detection results

mapCutterTraj: 	cut the wholemap to two parts: train & test, according to the poses attached

errorDistribution:		save the NN matched distance between the salient points and salient results

DBSCANFilter:			DBSCAN clustering and filter the noises points for SegMatch next step

LocTest:				Test of localization on the result map

mapScoringIndex:      accumalte laser-based experience map, range limited, need new one for Quardratic Programming

matchOut:      			get the matched count by aligning point clouds using ground truth poses, 1-1 for velodyne cloud

genVisMatrix:         generate the rows of visibility matrix A by aligning, k-search for map points

loadProResult:       load the programming results from files and save cloud

scanRegister:         registation the origin scans using ground truths to get origin map

genWeightVector:      generate the q vector by the obseration counts, the session descriptor


